#!/bin/bash
# Sequenced, automated testing.


## End of header.


# Some config to get us going.
shestDir="shest"
userConfigLocation=~/.config/shest

defaultConfig="# Config for shest

# Test types for each stage.
# testTypes=\"unit integration regression\"
testTypes=\"unit\"

# Where should the tests be run?
testLocation=\"/tmp/shest-\$\$\"
# testLocation=\".\"
# testLocation=~/shest/shest-\$\$

# Delete temporary files after the test finishes.
deleteTmp=always
# deleteTmp=success
# deleteTmp=failure
# deleteTmp=never

# Delete logs after the test finishes.
# If testLocation is in /tmp, set this to never to avoid an annoying warning.
deleteLogs=never
# deleteLogs=success
# deleteLogs=failure
# deleteLogs=never

# Is a warning a failure?
# Generally it should be. But sometimes you want to know about stuff that isn't optimal, but not breal the build for it. If that's the case for you, this is the setting to change.
warningIsAFailure=true
# warningIsAFailure=false

# Copy origin directory if testLocation is not \".\"?
# You will almost want to do keep this set to true. It is useful to set this to false when testing the unit tester. I can't currently think of another use case. But it's here if you need it.
copyOrigin=true
# copyOrigin=false
"

newTest="#!/bin/bash
# Write a decription of the test here.

. $0 \"--doNothing\"

result=\"\$(doSomething)\"
exitCode="\$?"

if [ \"\$result\" == 'something expected' ] && [ \"\$exitCode\" == \"\$passCode\" ] ; then
    pass \"Great!\"
elif [ \"\$result\" == 'something good, but might be a problem' ]  && [ \"\$exitCode\" == \"\$warnCode\" ] ; then
    warn \"This is within range, but could be a problem. value=\\\"\$result\\\".\"
elif [ \"\$exitCode\" == \"\$failCode\" ]; then
    fail \"Got exitCode \$exitCode. Value=\\\"\$result\\\".\"
else
    fail \"Got value=\\\"\$result\\\".\"
fi
"

colourReset='\033[0m'
colourBlack='\033[0;30m'
colourRed='\033[0;31m'
colourGreen='\033[0;32m'
colourBrown='\033[0;33m'
colourBlue='\033[0;34m'
colourPurple='\033[0;35m'
colourCyan='\033[0;36m'
colourGrey='\033[0;37m'

colourDarkGrey='\033[1;30m'
colourBrightRed='\033[1;31m'
colourBrightGreen='\033[1;32m'
colourYellow='\033[1;33m'
colourBrightBlue='\033[1;34m'
colourBrightPueple='\033[1;35m'
colourBrightCyan='\033[1;36m'
colourWhite='\033[1;37m'

colourNormal="$colourReset$colourGrey"
colourPass="$colourGreen"
colourWarn="$colourBrown"
colourFail="$colourRed"
colourInsignificant="$colourDarkGrey"
colourTestName="$colourCyan"
colourTestMessage="$colourNormal"
colourStage="$colourPurple"
colourTestSet="$colourYellow"

if [ "$DEBUG" == '' ]; then
    DEBUG=0 # This can be set in an environment variable or in config.
fi

# Here are a couple of functions to get us going.
function errorExit
{
    local message="$1"
    echo "$message" >&2
    exit 1
}

function findShestHome
{
    if [ -e "$shestDir/config/general" ]; then
        echo "$(pwd)"
    elif [ "$(pwd)" == '/' ]; then
        return 1
    else
        cd ..
        findShestHome
    fi
}

# Load configured defaults.
if [ -e "/etc/shest/defaults" ]; then
    . "/etc/shest/defaults"
fi

if [ ! -d "$userConfigLocation" ] && [ -e "/etc/shest/" ] ; then
    mkdir -p "$userConfigLocation"
    cp /etc/shest/* "$userConfigLocation"
fi

if [ -e "$userConfigLocation/defaults" ]; then
    . "$userConfigLocation/defaults"
fi

# Figure out exactly where our home is and load our config.
originalTestLocation="$testLocation"
shestHome="$(findShestHome)"
if [ "$SHEST_CONFIG" == '' ]; then
    SHEST_CONFIG="$shestHome/$shestDir/config/general"
fi

if [ -e "$SHEST_CONFIG" ]; then
    . "$SHEST_CONFIG"
elif [ "$1" == '--createProject' ] || [ "$1" == '--help' ]; then # Shut up and let them do it! ;)
    true
else
    errorExit "It looks like shest has not been initilised on this project yet. You can do so by running \"$0 --createProject\"."
fi

# If we are being called as a library for a test, we don't want to reset the testLocation provided by the original caller.
if [ "$originalTestLocation" != '' ]; then
    testLocation="$originalTestLocation"
    unset originalTestLocation
fi

# Load configured overrides.
if [ -e "/etc/shest/overrides" ]; then
    . "/etc/shest/overrides"
fi

if [ -e "$userConfigLocation/overrides" ]; then
    . "$userConfigLocation/overrides"
fi




# Now we can get to the main meat of the program.
function debugOut
{
    local level="$1"
    local message="$2"
    
    if [ "$level" -le "$DEBUG" ]; then
        echo "Debug $level: $message"
    fi
}

function notImplemented
{
    local thing="$1"
    
    errorExit "$thing is not implemented yet."
}

function createProject
{
    mkdir -p "$shestHome/$shestDir/"{config,stages}
    createConfig
}

function createConfig
{
    echo "$defaultConfig" > "$shestHome/$shestDir/config/general"
}

function createStage
{
    local stageName="$1"
    
    mkdir -p "$shestHome/$shestDir/stages/$stageName"
}

function createTestTypes
{
    cd "$shestHome/$shestDir/stages"
    
    for stage in $(ls -1); do
        for testType in $testTypes; do
            finalDir="$stage/$testType"
            
            if [ ! -e "$finalDir" ]; then
                mkdir -p "$finalDir"
            fi
        done
    done
}

function createTest
{
    local fileName="$1"
    
    echo "$newTest" > "$fileName"
    chmod 755 "$fileName"
}

function prepTests
{
    echo "Going to run tests in \"$testLocation\"."
    mkdir -p "$testLocation"
    cd "$testLocation"
    
    mkdir -p "$shestDir/"{tmp,log}
    
    if [ ! -e "$shestDir" ]; then
        if [ "$copyOrigin" == 'true' ]; then
            # For most use-cases, this will be true. But if shest is configured to use the project directory as its testLocation, all of this stuff will already exist.
            rsync -rl "$shestHome"/* .
        fi
    fi
    
}

function runTests
{
    # Prep.
    prepTests
    failures=0
    warnings=0
    failuresAndWarnings=0
    export RESULTS_FILE="$testLocation/$shestDir/tmp/results.csv"
    
    # Do.
    export testLocation
    for stage in $(ls -1 "$shestHome/$shestDir/stages" | sort -u); do
        indentation=''
        stageDir="$shestHome/$shestDir/stages/$stage"
        echo -e "${colourStage}Stage${colourInsignificant}: ${colourNormal}$stage"
        for testItem in $(ls -1 "$stageDir" | sort -u); do
            testItemEntity="$stageDir/$testItem"
            if [ -f "$testItemEntity" ]; then
                export TEST_NAME="$stage_$testItem"
                export TEST_FILE="$testItemEntity"
                export indentation='  '
                
                runTest
            elif [ -d "$testItemEntity" ]; then
                echo -e "${indentation}${colourTestSet}Test set${colourInsignificant}: ${colourNormal}$testItem"
                for subTestItem in $(ls -1 "$testItemEntity" | sort -u); do
                    export TEST_NAME="$stage_$testItem_$subTestItem"
                    export TEST_FILE="$testItemEntity/$subTestItem"
                    export indentation='    '
                    
                    runTest &
                done
                wait
            fi
        done
    done
    
    showAnalytics
    
    # Clean up.
    if [ "$warningIsAFailure" == 'true' ]; then
        valueToTest="$failuresAndWarnings"
    else
        valueToTest="$failures"
    fi
    
    if [ "$valueToTest" -eq 0 ]; then
        cleanUp 'true'
        return 0
    else
        cleanUp 'false'
        return 1
    fi
}

function runTest
{
    startDir="$(pwd)"
    cd "$testLocation"

    export TEST_RESULT_FILE="$testLocation/$shestDir/tmp/$TEST_NAME.result"
    export TEST_DESCRIPTION="$(head -n2 "$TEST_FILE" | tail -n1)"
    export SHEST_CONFIG
    
    $TEST_FILE 2> "$testLocation/$shestDir/log/$TEST_NAME.log" 1>&2
    cat "$TEST_RESULT_FILE"
    
    cd "$startDir"
}

function showAnalytics
{
    passed="$(grep "^pass," "$RESULTS_FILE" | wc -l)"
    warnings="$(grep "^warn," "$RESULTS_FILE" | wc -l)"
    failures="$(grep "^fail," "$RESULTS_FILE" | wc -l)"
    
    let failuresAndWarnings=$failures+$warnings
    
    echo
    echo -e "${colourPass}Pass${colourInsignificant}: ${colourNormal}$passed${colourInsignificant}, ${colourWarn}Warn${colourInsignificant}: ${colourNormal}$warnings${colourInsignificant}, ${colourFail}Fail${colourInsignificant}: ${colourNormal}$failures"
}

function cleanUp
{
    local completeSuccess="$1"
    
    case "$deleteTmp" in
        'always')
            cleanTmp
        ;;
        'success')
            if [ "$completeSuccess" == 'true' ]; then
                cleanTmp
            fi
        ;;
        'failure')
            if [ "$completeSuccess" == 'false' ]; then
                cleanTmp
            fi
        ;;
    esac
    
    case "$deleteLogs" in
        'always')
            cleanLogs
        ;;
        'success')
            if [ "$completeSuccess" == 'true' ]; then
                cleanLogs
            fi
        ;;
        'failure')
            if [ "$completeSuccess" == 'false' ]; then
                cleanLogs
            fi
        ;;
    esac
}

function cleanTmp
{
    if [ "${testLocation::5}" == '/tmp/' ]; then
        debugOut 1 "deleteTmp==\"$deleteTmp\" and testLocation ($testLocation) is in /tmp. So deleting everything, including logs, which are also in the same directory."
        cd "$shestHome"
        rm -Rf "$testLocation"
    else
        debugOut 0 "deleteTmp==\"$deleteTmp\", but testLocation ($testLocation) is not in /tmp. So only deleting tmp in this line."
        cd "$testLocation"
        rm -Rf "$shestDir/tmp"
    fi
}

function cleanLogs
{
    if [ "${testLocation::5}" == '/tmp/' ]; then
        debugOut 0 "Deleting logs, but testLocation is in /tmp, so if tmp is configured to be deleted, logs will get deleted anyway."
    fi
    cd "$testLocation"
    rm -Rf "$shestDir/log"
}


# Stuff for sending test results to the right place.
function pass
{
    local message="$1"
    
    setResult "pass" "$message"
}

function warn
{
    local message="$1"
    
    setResult "warn" "$message"
}

function fail
{
    local message="$1"
    
    setResult "fail" "$message"
}

function setResult
{
    local result="$1"
    local message="$2"
    
    case $result in
        'pass')
            colourResult="$colourPass"
        ;;
        'warn')
            colourResult="$colourWarn"
        ;;
        'fail')
            colourResult="$colourFail"
        ;;
    esac
    
    
    echo -e "$indentation$colourInsignificant[$colourResult$result$colourInsignificant] $colourTestName$TEST_NAME$colourInsignificant: $colourTestMessage$message" > "$TEST_RESULT_FILE"
    echo "$result,$TEST_NAME,$TEST_DESCRIPTION,$message" >> "$RESULTS_FILE"
}


# Stuff for command line parsing.
function requireParameter
{
    local parameterName="$1"
    local parameter="$2"
    
    if [ "$2" == '' ]; then
        errorExit "Parameter \"$parameterName\" is required. Consult $0 --help for more info."
    fi
}

function showHelp
{
        grep -B1000 '^## End of header.' "$0" | grep '^# ' | cut -b3-
        grep "') #" "$0" | grep -v grep | sed "s/^ *'/  /g; s/') #/^/g" | column -s^ -t
}

case $1 in
    '--createProject') # Create a bare project in the current directory.
        createProject
        echo "Excellent. Now take a look at the config in \"$shestHome/config/general\", and then create a stage with \"$0 --createStage stageName\", then run \"$0 --createTestTypes\"."
    ;;
    '--createConfig') # Re-create the config used be shest. This is normally done for you. But will be useful if you upgrade shest and need the latest config. It will override what ever you have in place.
        createConfig
    ;;
    '--createStage') # Create a new stage. --createStage stageName
        requireParameter "stageName" "$2"
        createStage "$2"
    ;;
    '--createTestTypes') # Create the test types based on what's in the config.
        createTestTypes
    ;;
    '--createTest') # Create a test in the current directory. --createTest testName.sh
        requireParameter "testName" "$2"
        createTest "$2"
    ;;
    '--run') # Run the tests.
        runTests
        exit $?
    ;;
    '--help') # Show this help.
        showHelp
    ;;
    '-h'|'/?'|'help')
        showHelp
    ;;
    '--doNothing')
        # This is so the script can be included in tests to use it as a library.
        true
    ;;
    *)
        runTests
        exit $?
    ;;
esac
